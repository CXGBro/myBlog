---

---

#  HTML

## src与href的区别

两者都是请求外部的文件,src会将请求到的文件内容添加到html文件里,同时src会堵塞文件的加载,其实就是同步加载

href则仅仅建立外部文件与html文件之间的一种链接,href不会堵塞文件的加载,其实也是异步加载

## link与@import的区别

link为异步加载,@import是同步加载

@import会嵌入内容到html中,link则不会

## HTML语义化标签

```
header
footer
nav
section
```

## DOCTYPE的意义

告知浏览器使用哪一种文档类型定义来解析文档

在HTML5中,直接声明即可

## defer与async的区别

两者都可以异步请求资源,防止文档读取的堵塞

defer注意是异步加载,不是异步请求,也就是浏览器在读取到加载js标签时,会一边请求资源,一边继续向下读取html,直到读取完成后,再异步加载(执行)js代码

async就是单纯的异步,不会出现先请求再执行的情况.

## HTML5新增了哪些东西

1.语义化标签 2.本地存储 3.媒体标签 4.canvas 5.history API 6.websocket通信协议

## 介绍一下webworker

# CSS

## 左侧固定,右侧自适应

flex:

```css
.main{
      display: flex;
    }
    .left{
      background: red;
      width: 300px;
      /* 内容超出主轴的时候这一部分不会被压缩 */
      flex-shrink: 0;
    }
    .content{
      background-color: blue;
      /* 占满整个剩余部分 */
      flex-grow: 1;
    }

  <div class="main">
    <div class="left">左侧</div>
    <div class="content">右侧</div>
  </div>
```

grid:

```css
.main{
      display: grid;
      // 左边占300px 右边占所有的比例
      grid-template-columns: 300px 1fr;
    }
```

float+BFC

```css
.left{
      background: red;
      /* 让其脱离标准流 */
      float: left;
      width: 300px;
    }
    .content{
      background-color: blue;
      /* 触发BFC */
      overflow: hidden;
    }
```



## 清除浮动的方法:

1. clear属性,将标准流(文档最上面的元素)移动到所有浮动元素的下面

   实际操作中通过添加一个类名为line的div,(是标准流)让它跑到浮动元素的下面撑起来整个父元素

   1. left 移动到左浮动的下面
   2. right 移动到右浮动的下面
   3. both 两者同时的下面

2. 伪元素方式(核心思路就是把 一个元素放到所有浮动元素的下面

   ```css
   <div class="clear-fix">
   	<浮动元素></>
   	<浮动元素></>
   </div>
   
   
   .clear-fix::after{
   	content:'';  //在浮动元素的后面添加一个伪元素,内容为空,让它跑到所有浮动元素的后面
   	clear:both;
   	display:block;  //伪元素的默认格式是行内元素
   	
   }
   ```

   

## 讲一下CSS定位吧

1. static: position属性的默认值,元素不会脱离标准流,也不会成为定位元素

2. relative: 相对于自己的位置的定位,元素不会脱离标准流

3. absolute: 相对于自己第一个非static属性的父级元素的定位,如果没有相对于视口

4. fixed: 相对于视口的定位,窗口滚动时不会影响fixed. 

   > 视口(viewport): 自己能看到的页面
   >
   > 画布(canvas): 整个窗口大小

为什么子绝父相:1.让子元素找到相对的元素 2. 父亲不要脱离标准流

5. sticky: 默认为relative,设置的属性值触发以后变为fixed

比较常见的就是搜索栏,向下滚动的时候自动跟着你的屏幕滚

## 盒模型

```
标准盒模型
content-box 
IE盒模型 box-sizing: border-box;
```



## 实现一个三角形

```
核心原理,内容区设置为0,然后设置边框,将边框设置为透明色,那个方向需要三角形,就设置哪个方向的颜色
#test{
      width: 0;
      height: 0;
      border:solid 100px transparent;
      border-bottom:solid 100px red;
    }
```

## 权重问题

不同的选择器会有不同的权重,权重越大,意味着选择器属性的渲染优先级越高.

 !important>行内样式>id>类 属性 伪类>标签 伪元素>通配符选择器

权重问题是基于层叠性而来,

!important：10000  内联样式：1000  id选择器：100  类选择器、属性选择器、伪类：10  元素选择器、伪元素：1  通配符：0

## 毛玻璃的实现效果

重点在于backdrop-filter,该属性的作用在于让元素的后面元素添加一些效果,如模糊等



## 水平垂直居中的方式

```html
.parent {
      width: 200px;
      height: 100px;
      /* position: relative; */
      background-color: #374858;
    }

    .parent .child {
      width: 100px;
      height: 50px;
      background-color: #9dc3e6;
    }

<div class="parent">
    <div class="child"></div>
</div>
```

### 水平居中

子元素为内联元素(行内块元素为内联元素),

为**父元素**设置text-align

```
.parent
```

子元素为块级元素

为子元素设置margin:0 auto

```css
.child{
      margin: 0 auto;
}
```

使用绝对定位

相对定位是相对自己原来的位置的定位

绝对定位是相对自己的父级元素的定位

```css
.child{
      position: absolute;
      left: 50%;
      transform:translate(-50%,0);
    }
```

使用flex布局

在**父元素**上使用justify-content,规定flex-item在主轴上的对齐方式

```css
.parent{
      display: flex;
      justify-content: center;
    }
```

### 垂直居中

```css
.parent{
      display: flex;
      align-items:center;
    }
    

// 针对表格元素???
.parent{
      display: table-cell;
      vertical-align: middle;
    }
    
// 定位很容易想到
.child{
      position:absolute;
      top: 50%;
      transform:translate(0,-50%);
    }
```

### 两者 同时居中

```
块元素
.child{
      position:absolute;
      top: 50%;
      left: 50%;
      transform:translate(-50%,-50%);
    }
    
    //flex
.parent{
      display: flex;
      justify-content: center;
      align-items: center;
    }

行内块元素
```

## BFC

块级格式化上下文,当你在使用某些css属性的时候会触发BFC,这个上下文环境独立于其它的环境,不受其他的环境影响.

## BFC及其应用

## 解决高度塌陷问题

子元素采用了浮动,就脱离了标准流,这样它就不会向父元素汇报高度,父元素认为子元素没有高度,就会造成高度塌陷

1. 

# JavaScript

## JS运行机制与原理

### JS内存存储原理与垃圾回收机制

内存分为了栈空间与堆空间

栈空间存放了全局执行上下文与函数执行上下文,执行上下文中,基本数据类型直接通过键值对的方式存储.引用类型存储方式是它的值为内存地址,也就是说它存储了引用类型的引用,内存地址指向堆空间

![image-20221127145154279](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221127145154279.png)

为什么不能只有栈空间?

1. 当所有数据都放到栈空间时,栈的上下文切换变得很困难.比如从全局上下文转向函数上下文时,只要将指向全局上下文的指针移动到函数上下文就可以了.数据太大造成指针转移的效率大大降低

如何进行垃圾回收?

1. 对于栈空间,比如顶层的函数执行完毕,需要内存回收.直接将指针下移,就完成了栈空间的内存回收

那堆空间呢?

1. 将堆空间分为两部分,一部分为老生代,存放存放时间长的对象.一部分为新生代,空间很小,存放时间短的对象
2. 老生代使用主垃圾回收器,新生代使用副垃圾回收器
3. 

### js继承原理

```js
// 预设代码
function Person(name,age){
  this.name=name;
  this.age=age;
}

Person.prototype.running=function(){
  console.log(this.name+'running');
}

function Student(sno){
  this.sno=sno
}

Student.prototype.studying=function(){
  console.log(this.name+'studying');
}
```

#### 原型链继承

思路:要想实现子类继承父类,子类的原型对象中得包括父类

两种方案:1.子类原型为父类的原型,`Student.prototype=Person.prototype`但这样会造成person的内容太多

2.子类原型为父类的实例对象`Student.prototype=person`

```js
function Person(name,age){
  this.name=name;
  this.age=age;
}

Person.prototype.running=function(){
  console.log(this.name+'running');
}

let person = new Person('cheng',18);

function Student(sno){
  this.sno=sno
}

Student.prototype=person;

Student.prototype.studying=function(){
  console.log(this.name+'studying');
}

let student = new Student(0001);
console.log(student);
```

但此时就有问题:1.student对象不能看到自己的父类person对象里的属性,只能看到自己的属性

2.person对象里的属性是写死的,不能随着student的生成而更改

#### 借用构造函数继承

上面的问题是,student能获得person的属性,却没法自定义person的属性

于是在子类使用父类的构造函数让父类的属性与方法定义语句在子类中执行,子类就实现了自定义属性

```js
function Person(name, age) {
      this.name = name;
      this.age = age;
    }

    Person.prototype.running = function () {
      console.log(this.name + 'running');
    }

    let person = new Person('cheng', 18);

    function Student(name,age,sno) {
      // 此时this指向了student的实例对象
      Person.call(this,name,age);
      this.sno = sno;
    }

    Student.prototype = person;

    Student.prototype.studying = function () {
      console.log(this.name + 'studying');
    }

    let student = new Student('hah',20,0001);
    console.log(student);
```

#### 组合借用继承

以上的两种方法被称为组合借用继承,它们有问题:

1. 借用构造函数时把父类的属性写在了子类里,造成了代码重复
2. 在很多情况下,这种继承方式调用了两次父类构造函数.一次在生成父类实例中,一次在借用父类的构造方法中

#### 原型式继承

明确如果搞成继承:子类实例的隐性原型为父类构造函数的显示原型

student.__proto__==Person.prototype; 这样会把大量的属性都堆到父亲上面去;

这里改进方法,找一个中间量来过度

```js
function Student(){};
function Person(){};

let obj={};
Object.setPrototypeOf(obj,Person.prototype);
Student.prototype=obj;

// 化简以后为
let obj = Object.create(Person.prototype);
Student.prototype=obj;

// 实际开发过程中会进行封装
function inherit(Subtype,Supertype){
  let obj=Object.create(Supertype.prototype);
  Subtype.prototype=obj;
  return Subtype;
}
```

#### 寄生组合式继承

```js
// createObject(为了解决object.create的兼容性而存在)
function createObject(obj){
    let F = function(){};
    F.prototype=obj;
    return new F();
}
// 寄生函数
function inherit(Subtype,Supertype){
  Subtype.prototype=createObject(Supertype.prototype);
  return Subtype;
}
```



### 函数柯里化

只传给函数一部分的参数,让它返回一个函数去处理剩余的参数

柯里化使得函数的功能更加单一,这样更方便我们写逻辑

封装一个函数,使得新产出的函数可以随意调用参数的数量

```js
function add(x,y,z){
  return x+y+z
}

function currying(fn){
  return function isEnough(...args){
    // 如果调用柯里化函数时传入的参数不满足调用整个函数时,进行参数合并后再调用
    if(args.length>=fn.length){
      return fn(...args)
    }else{
      return function(...args2){
        return isEnough(...args,...args2)
      }
    }
  }
}

const curriedAdd = currying(add)
console.log(curriedAdd(1,2,3));
console.log(curriedAdd(1)(2,3));
console.log(curriedAdd(1)); //如果参数不够执行戛然而止返回一个匿名函数
```

### 普通函数与箭头函数的区别

箭头函数本身也没有绑定arguments

箭头函数不绑定this,它的this需要到上层的作用域的上下文对象中去寻找

或者也可以说箭头函数绑定的是上层作用域的上下文对象

箭头函数的底层实现原理是.bind(this),也就是返回一个改变this后的函数

### 事件循环机制

#### 以下为浏览器中的情况

就是js引擎去处理代码时的顺序

1. 一般自上而下处理任务,把任务放到上下文调用栈中
2. 部分任务放到任务队列中
   1. 宏任务: ajax 计时器 DOM监听 UI rendering
   2. 微任务: promise的then回调 queueMicroTask()
   3. 在任何一个宏任务执行之前,都得确保微任务已经执行完毕
3. 待上下文调用栈中的所用任务执行完毕后,任务队列中的任务会入栈执行

#### node中的情况完全不同

### V8引擎(JS引擎架构)

V8引擎完成了将普通的代码转换为机器可以识别的字节码

编译器与解释器

![image-20221127012221691](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221127012221691.png)

包括

1. Parse模块
   1. 生成执行上下文
   2. 完成词法分析与语法分析,将代码转换成AST语法树

2. ignition模块
   1. 将AST转换成ByteCode（字节码）,并且一条一条的执行字节码,字节码可以理解为机器码的抽象
   1. 对于第一次执行的代码,ignition解释器直接将字节码转换为机器码运行.如果在这个期间遇到了可以重复利用的热点代码(hotspot),就交给turbofan来保存字节码转换后的机器码,下次再次解释该段代码时可以直接使用这里的机器码
   1. 之所以没有直接转换为机器码,是因为机器码的内存占用大小远远大于字节码,这样会造成内存占用量太大
3. turbofan模块
   1. 将字节码编译为CPU可以直接执行的机器码(在这段过程中,如果遇到了可以使用多次的代码,可以直接多次使用,实现重复利用)

经过字节码的中间过程,再加上热点代码的加持,效率比直接使用机器码差不多,内存占用减少不少

## 数据类型

#### API相关

##### 数组API的实践(是否改变原数组)

##### Promise

then all allSettle race any resolve reject

##### Object

###### Object.assign

**`Object.assign()`** 方法将所有[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable)（`Object.propertyIsEnumerable()` 返回 true）的[自有](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)（`Object.hasOwnProperty()` 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。

即从源对象先拷贝所有可枚举的自身的属性到目标对象,返回拷贝后的对象.**会改变源对象**

`Object.assign(target,source)`

##### Array

###### array.includes array.indexOf

判断是否包含某个值,includes返回boolean.indexOf返回索引

##### ES6新增的内容

1. let const
2. 函数上的拓展：
   1. 箭头函数
   2. 剩余参数
   3. 默认参数
3. 对象上的拓展：
   1. class module
   2. Proxy
   3. Promise（aysnc/await）
   4. Set Map WeakSet WeakMap
4. 字符串上的拓展：模板字符串
5. 新增数据类型：bigInt symbol
6. 新增运算符： `**` `??` 

### js的基本类型有哪些

number string boolean null undefined symbol bigint

### NaN

```js
let name="cheng";
name = name*2;
// 值为NaN
```

### set map weakset weakmap

map与对象类型,也是键值对的形式,但是map的键的类型不止是string或者symbol,可以是任意类型.

set 与 map都是有序的 它们也都可以迭代 能使用for of 遍历. array也可以.object不可以

set类似如数组,不过set是不能存在重复元素的.因此可以利用set来进行数组去重

weakset与weakmap的重要特性是,它们都是弱引用

<img src="C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5YWt5Y-26I2Jfg==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom:50%;" />

弱引用是虚假的连接,是手指的指向.一旦连接狗的绳子断了以后,狗就没有了

因此,放入weakset里的对象,一旦外部对它的引用消失,它就会被内存回收.weakset本身对它的引用并没有效果.

weakset里的元素只能是对象,weakmap元素的key也只能是对象.它们没有迭代的能力

## 手写实现

### 手写instanceof

instanceof用于判断左边的对象是否是右边函数的实例

```js
{} instanceof Object  // true
```

其原理在于左边的对象原型链上是否包含右边的原型对象

右边的原型对象是否在左边对象的原型链上

```js
function newInstanceof(obj, fn) {
  while (true) {
    // 这里检测到顶层原型null为止,因为上面再也没有原型了
    // 如果仅仅是原型为null,有可能函数的原型也为null,这会少检测一次原型为null的情况
    if (obj === null) {
      return false;
    }
    if (obj.__proto__ === fn.prototype) {
      return true;
    }
    obj = obj.__proto__;
  }
}

console.log(newInstanceof({},Object));
```

### 手写Array.filter

```js
Array.prototype._filter=function(fn){
                let newArray = []
                this.forEach((item,index,array)=>{
                    if(fn(item,index,array)){
                        newArray.push(item)
                    }
                })
                return newArray
            }
```



6. 





## 设计模式

### 观察者模式

目标对象:

- 维护观察者列表
- 告知观察者状态更新

观察者:

- 更新自己的状态

```
class TargetObject {
  constructor() {
    this.ObserverList = []
  }
  addObserver(observer) {
    this.ObserverList.push(observer)
  }
  notify() {
    this.ObserverList.forEach(item => {
      item.update()
    })
  }
}

class observer {
  update() {
  }
}
```

### 介绍一下发布订阅模式

利用构造函数,创建一个观察者来观察是否有

- 发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是事件触发

- 调度中心(Event Channel)也就是中介,负责任务订阅管理,提供订阅功能,发布订阅任务

- 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel）

```js
class EventChannel{
  constructor(){
    this.events={}
  }
  subscribe(type,callBack){  // 在eventbus中,on就是订阅,emit就是发布
    if(!this.events[type]){
      this.events[type]=[]
    }
    this.events[type].push(callBack)
  }
  publish(type,...args){
    this.events[type].forEach(element => {
      element(...args)
    });
  }
}

let eventChannel = new EventChannel();
eventChannel.subscribe('warname',()=>{
  console.log('warname');
})
eventChannel.publish('warname')
```

## 场景应用

### 实现懒加载

#### 使用scroll滚动事件

获取浏览器窗口的高度`window.innerHeight`

元素到窗口顶部的距离`element.getBoundingClinetRect().top`

getBoundingClinetRect()

`getBoundingClientRect()` 提供了元素的大小以及视口的位置

1. 在元素身上自定义一个属性
2. window对象上监听滚动事件,滚动事件一旦触发,遍历所有需要懒加载的元素判断它的高度与浏览器视口之间的关系

```html
<img data-src="./images/幻灯片1.JPG" alt="">
  <img data-src="./images/幻灯片2.JPG" alt="">
  <img data-src="./images/幻灯片3.JPG" alt="">
  <p>幻灯片1.JPG
    幻灯片2.JPG
    幻灯片3.JPG
    幻灯片15.JPG</p>
    <script>
      var img = document.querySelectorAll('img');
      window.addEventListener("scroll",(e)=>{
        img.forEach(image=>{
          const imgTop=image.getBoundingClientRect().top;
          if(imgTop<window.innerHeight){
            const data_src =image.getAttribute('data-src');
            image.setAttribute('src',data_src); 
          };
          console.log('scroll已触发')
        })
      })
```

#### IntersectionObserver

它的用法非常简单。

> ```javascript
> var io = new IntersectionObserver(callback, option);
> ```

目标元素的可见性变化时，就会调用观察器的回调函数`callback`。

`callback`一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。

```javascript
// 开始观察
io.observe(document.getElementById('example'));

// 停止观察
io.unobserve(element);
```

## 经典闭包面试题

为什么会保存最后一个变量

```js
var divElems = document.getElementsByTagName('div');
for (var i = 0; i < divElems.length; i++) {
  var elem = divElems[i];
  elem.onclick = function () {
    console.log(i);
  }
}
```

## 手写Array.map

先想,这个东西是干什么用的?(注意是直接修改原数组还是返回一个新的数组?)

```js
Array.prototype._map=function(callback){
                let res=[];
                 this.forEach((item,index)=>{
                     res.push(callback(item));
                 })
                return res;
            }
```

## 跨域

出现跨域问题是由于浏览器的同源策略导致的

同源:协议 端口 主机

浏览器将跨域行为分成了3类,包括`reads writes embedding(资源嵌入)`

### jsonp

同策略的影响,浏览器不允许使用xhr请求不同源的网站(跨域读)

但在页面上引入不同源的js脚本是可以的(跨域嵌入)

使用jsonp解决跨域就是利用script标签请求资源然后进行进一步的处理

缺点: 只能发送GET请求; 优点是兼容性较好

## 事件传播机制与事件代理

监听事件流的两种方式:事件冒泡与事件捕获

一下可以理解为事件传播机制:

- 从最外层元素向内传播,遇到绑定了捕获事件的元素会触发事件

- 找到事件触发元素,触发事件

- 从内向外传播,遇到元素绑定冒泡事件会触发冒泡事件

在使用addEventlistener时,对于第三个参数可以指定 是捕获阶段触发还是冒泡阶段触发

第三个参数可以指定为对象

```
once:true 实现只触发一次事件
passive: 消极的 
```

在事件源对象上,有几个方法,对事件传播有进一步的功效

```
preventDefault: 阻止事件的默认行为
stopPropagation: 禁止冒泡或捕获事件的进一步传播
stopImmediatePropagation: 除了阻止事件的进一步传播,还禁止调用该元素其它的事件监听
```

## 事件委托原理与实现

主要利用js中的事件监听机制--冒泡机制,将子元素的事件监听放到父元素上,子元素被点击后,事件将随着冒泡阶段传递到父元素上,通过event.target来获取子元素对象.

## 为什么0.1+0.2 != 0.3

注意,这个结果为0.30000000xx4

主要问题是js进行进制转换过程中,转换二进制后是一个无限循环的小数,js会剪掉一定的位数来保留精度,这样两个数相加后依然不是一个小数,而是一个循环小数

解决方法:

toFixed可以返回一个指定位数的小数,返回的小数类型为字符串,需要parseFloat来转换

```js
console.log(parseFloat((0.1+0.2).toFixed(1))===0.3);
```

## new运算符

```js
function create(fn,...args){
  let obj={};
  Object.setPrototypeOf(obj,fn.prototype);
  // 改变this
  fn.apply(obj,args);
  return obj;
}

function cons(val,num){
  this.val=val;
  this.num=num;

  // 如果这里return了一个东西,就需要做进一步的处理???
    // 这里看不明白,为何要进一步的处理
  return 5;
};

let obj = create(cons,11,22);
// 返回一个新对象
// 原型对象一致
// cons.apply(obj,args)
console.log(obj);
```

## Promise

promise就是承诺的意思,承诺未来某一个时间一定会做某一件事

promise进行异步请求后,会把状态与数据保存起来,因此它的回调可以随时执行

他的callback可以拿到结果后再执行,而普通的事件(不使用Promise时)处理回调需要在执行 之前设置好,也就是说你的callback什么时候执行是不确定的

```
// 传统的异步回调
const data = axios.get({url:'http://www.baidu.com'})
data.trim()
```



```js
let promise = new Promise((reslove,reject)=>{
  //main函数
  setTimeout(() => {
    reslove('我是返回的结果')
  }, 1000); //模拟异步操作
}) 
//promise本体主函数执行完操作会拿到结果并保存起来

那么我要什么时候指定回调函数呢？？
想什么时候都可以，甚至可以加一个10s的定时器再指定毁掉函授
setTimeout(() => {
  promise.then(res=>{
    console.log(res);
  },err=>{
    console.log(err);
  })
}, 5000);
//我是返回的结果
```



### 实现promise的基本功能

```js
// 保存状态常量
const PROMISE_STATUS_PENDING = 'pending';
const PROMISE_STATUS_FULFILLED = 'fulfilled';
const PROMISE_STATUS_REJECTED = 'rejected';

class newPromise {
  // 英文执行器
  constructor(executor) {

    this.status = PROMISE_STATUS_PENDING;

    const resolve = (value) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        this.status = PROMISE_STATUS_FULFILLED;
        this.value = value;
        queueMicrotask(() => {
          this.onFulfilled(this.value);
        })
      };

    };

    const reject = (reason) => {
      if (this.status === PROMISE_STATUS_PENDING) {
        this.status = PROMISE_STATUS_REJECTED;
        this.reason = reason;
        queueMicrotask(() => {
          this.onRejected(this.reason);
        })
      };

    };

    executor(resolve, reject);
  };

  then(onFulfilled, onRejected) {
    this.onFulfilled = onFulfilled;
    this.onRejected = onRejected;
  }


}

// 手写一个promise
// 由此可见,之所以函数里有参数能够让你调用,是因为有人调用了该函数,并且把实参传入了进去
let promise = new newPromise((resolve, reject) => {
  resolve(111);
  reject(222);
})

// 一旦状态改变了,promise就可以调用then方法对返回的值进行处理
// 怎么处理,当然是调用你给传入的函数,也就是你传什么函数,它怎么处理
promise.then(value => {
  console.log(value);
}, reason => {
  console.log(reason);
})
```

### 实现一下Promise.all与Promise.race

all接受一个可迭代元素(Array,Map,Set),all返回一个新的promise对象,可迭代元素中有一个reject的promise,返回它的data,所有的都是resolve的promise,返回一个数组,值为它们的data

```js
Promise.newPromiseAll = (promises)=>{
  return new Promise((resolve,reject)=>{
    const allValues=[];
    promises.forEach(element => {
      element.then(value=>{
        allValues.push(value);
        if(allValues.length===promises.length){
          resolve(allValues);
        }
      },reason=>{
        reject(reason);
      })
    });
  })
}


const promise1 = Promise.resolve(3);
const promise2 = Promise.resolve(5);  // 如果元素是个数字呢?需要进行判断的.
const promise3 = new Promise((resolve, reject) => {
 reject('你完了')
});
Promise.newPromiseAll([promise1,promise2,promise3]).then(value=>{
  console.log(value);
},reason=>{
  console.log(reason);
})
```

race就是竞赛,谁先有返回值就返回对象状态的promise

```js
Promise.myRace=(promises)=>{
  return new Promise((resolve,reject)=>{
    promises.forEach(element => {
      element.then(value=>{
        resolve(value)
      },reason=>{
        reject(reason)
      })
    });
  })
}
```



## 介绍一下async与await,以及实现的原理



## 说一下并发与并行的区别

并行,共同执行,cpu有多个核心,就可以同时进行多个任务,任务在进行过程中互不打扰

并发,一个人做多个任务,且在做这多个任务时反复横跳,切换执行

## 介绍一下var let const

1. 作用域提升 放到全局上下文中 这么做解决了函数的互相调用问题

   ```js
   function test1() {
   	test2()
   }
   function test2() {
   	test1()
   }
   test1()
   ```

2. let没有作用域提升 在ECMA规范中,声明了但访问不到 不会挂载到window上

3. const 不可改变 但如果是引用类型,改变的话其实就是改变引用到的那个变量

## 介绍一下原型与原型链

js万物皆为对象,函数也是对象,对于一个构造函数来讲,它内置了一个prototype属性,该属性指向该构造函数的原型对象,该原型对象被成为显示原型.原型上的属性和方法可以被构造函数所创建出来的对象所继承.

构造函数的原型对象作为一个对象,它也有指向原型的prototype属性,该对象的原型对象被称为该对象的隐式原型.原型对象上也会有一个原型对象,经过这一层又一层的寻找,就形成了原型链.

js中每一个对象都会包含一个内置属性[[prototype]],这个属性指向一个对象,这个对象就是原型对象.当该对象调用某个方法或者属性时,如果对象本身没有,就会向它的原型对象上去寻找.原型对象上也会有一个原型对象,经过这一层又一层的寻找,就形成了原型链.

获取对象的原型有两种方法:`对象.__proto__`或使用`Object.getPrototypeOf`

同时,函数也有一个prototype属性,同上

new操作符,首先创建一个新对象,将新对象的原型指向构造函数的原型对象

原型对象上有一个constructor属性,该属性指向构造函数

## 介绍一下闭包

所谓闭包,通俗的讲就是内部函数可以访问到外部函数的作用域

由于对象内的变量一直被引用，所以这对象不会被垃圾回收机制回收。可以始终保持在内存中。

### 使用闭包解决问题

一下输出什么?

```js
for (var i = 1; i <= 5; i++) {
		setTimeout(function timer() {
		console.log(i)
	}, i * 1000)
}

//5个六,每个间隔1秒
```

解决方案

```
使用立即执行函数,把i作为参数传入进去
for (var i = 1; i <= 5; i++) {
  ; (function (i) {
    setTimeout(function () {
      console.log(i)
    }, i * 1000)
  })(i)
}

除此之外使用let
```

## 实现call apply bind

### bind

相较于call与apply,bind的方法在于return一个函数供调用,在调用的过程中把this改变并删除

```js
function test(hahaha,lalala){
  console.log(this,hahaha,lalala);
}

Function.prototype.newBind=function(thisArg,...args){

  // 这一层是返回函数后调用的参数位置
  let bindFunc=()=>{
    thisArg.fn=this;
    // 这一层是在调用newBind方法时就要传入的参数
    thisArg.fn(...args);
    delete thisArg.fn;
  }
  return bindFunc
}

let res = test.newBind({age:18},'hahaha')
res();
```

## 浅浅写一下cache工具类

```js
class Cache{
  setCache(key,value){
    localStorage.setItem(key,value);
  };

  getCache(key){
    return localStorage.getItem(key);
  }

  removeCache(key){
    localStorage.removeItem(key);
  }
}

let cacheUtil = new Cache();
```

## 深浅拷贝

### 浅拷贝的实现

使用object.assign

```
该方法传入多个参数,一个target对象,多个source对象.用于从一个或多个源对象中把所有可枚举(enumerable)且为自身(hasOwnProperty)的属性复制到目标对象中
```

除此之外,使用展开运算符可以轻松实现浅拷贝

```js
// 这是两种浅拷贝方式
let obj={
  name:''
}

const res = Object.assign({},obj);
const res2={...obj};

console.log(res);
console.log(res2);
```

### 深拷贝

深拷贝最简单的实现就是json,但有很多问题

好一点的方法是使用lodash的深拷贝函数

这里手写一个没有考虑太多边界条件的深拷贝

```js
let obj={
  name:'cheng',
  age:[111,222],
  hahah:{
    wawawa:'111',
    cacaca:[555]
  }
}

function isObject(item){
  return Object.prototype.toString.call(item)==='[object Object]';
}

function deepCopy(obj){
    // 非常经典的递归调用,这里要注意考虑到递归必须要return回去,if的判断写在前面而不是for里面
  if(!isObject(obj)){
    return obj;
  }

  let copyObj = {};
  for(let key in obj){
    copyObj[key] = deepCopy(obj[key]);
  }
  return copyObj
}

const res = deepCopy(obj);
console.log(res);
```



## ==与===的区别

核心点:==进行了类型转换

[]==![] 结果为true

## 构造一个100个0的数组

```
let arr = [];
for (let i = 0; i < 10; i++) {
  arr.push(0);
}
console.log('1', arr);

// fill以指定索引填充数组
// fill不会改变原数组
// 原型上的方法即实例方法是供这个数组实例调用的,而静态方法是让数组对象调用的

console.log(Array(10).fill(0));

// from返回一个传入的可迭代对象或类数组的浅拷贝实例,
// 可传入第二个参数作为每一个参数的回调,其实就是再调用了一次map方法
// 它不会改变原数组
let arr3 = [];
console.log(Array.from({length:10},item=>0));
```

## 如何将一个类数组转换为普通数组

```JS
let likeArray = {length:3};
let trans = Array.from(likeArray);
console.log(trans);

// 同样是遍历输出,使用拓展运算符会报错,因为拓展运算符只能适用于iterable元素
let likeArray = {length:3};
let trans = [...likeArray];
console.log(trans);

// 可以想到的普通做法
// 这里keys与values方法都返回一个数组
// 注意!entries返回的是一个二维数组,且每一个子元素均为数组的键值对;
// let obj={
// 	oneArr:[111,222,333],
// 	twoArr:[444,555,666]
//}
//[ [ 'oneArr', [ 111, 222, 333 ] ], [ 'twoArr', [ 444, 555, 666 ] ] ]
// 
let likeArray = {length:3};
let trans =[];
let key = Object.keys(likeArray)
let value = Object.values(likeArray)

for(let i=0;i<key.length;i++){
  trans.push(key[i]);
}

console.log(trans);

let likeArray = {
  0:0,
  1:1,
  2:2,
  length:3
};

// 使用数组方法可以转化,但如果直接调用会导致找不到相应的方法
const res = Array.prototype.slice.call(likeArray);
console.log(res);

let likeArray = {
  0: 0,
  1: 1,
  2: 2,
  length: 3
};

// 使用数组方法可以转化,但如果直接调用会导致找不到相应的方法
// const res = Array.prototype.slice.call(likeArray);
// console.log(res);

// 然后我这里使用不同的数组API,注意这里的使用特性
// const res = Array.prototype.concat.apply([],likeArray);
// console.log(res);

// 除了数组API,也别忘记了构造函数,其实这也算是API的一部分
const res = Array.apply(null, likeArray);
console.log(res);
```

## 稀疏数组

```js
// 稀疏数组是一个纯纯的空数组,注意不是元素为undefined的数组
// 为空的数组是不能使用map方法的,但元素为undefined是可以使用的
Array(10);
Array(10).map(item=>1); // 这不会改变数组,因为数组还是空的

// 构造100
console.log(Array(10).fill(1));

// 使用from进行迭代的过程中说明其把empty转换成了undefined
// 此时使用map方法是可以的
console.log(Array.from(Array(10),item=>1));
```

## 手写拍平flat

#### 拍平的层数没有解决

ES5

```js
// 使用数组类方法API判断是否为数组
// concat方法不会改变原有数组,而是返回一个新的数组

Array.prototype.flatten=function(number){
  // 我传入number了啊
  console.log(number);
  if(number<=0){
    return
  };
  let res =[];
  for(let i=0;i<this.length;i++){
    if(Array.isArray(this[i])){
      res = res.concat(this[i].flatten());
      console.log(number);
      number--;
    }else{
      res.push(this[i])
    }
  };
  return res;
}

let arr = [111,[222,[333]]];
let res= arr.flatten(1);
console.log(res);

```

ES6

```
// some用于判断数组中是否至少有一个元素通过了提供的函数测试
function flatten(arr) {
  while (arr.some(item => Array.isArray(item))) {
    // 注意这里的解构赋值,111先放进数组里,222,[333]再放进数组里
      arr = [].concat(...arr);
      //此外,这里每一次赋值都直接改变了数组原值,否则就会进入死循环
  }
  return arr;
}

let arr =[111,[222,[333]]];
console.log(flatten(arr));
```

## 防抖节流

防止手抖,如果在限定时间内有一次发送请求,就停止这次请求,重新计时直到设定的时间

```js
  // 防抖最终是一种函数,封装要防抖的东西
    function debounce(fn, wait) {
      let timer;
      
      let _debounce = (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            fn(...args);
          }, wait)
      }
      // 我们的函数的最终目的就是返回一个防抖函数
      // 让用户在click时运行这个防抖函数
      return _debounce
    }

    let input = document.querySelector('input');

    // debounce是window调用的
    // 调用以后返回的_debounce函数是button调用的
    // 因此_debounce函数可以接收到event事件对象
    input.addEventListener('input', debounce((event) => {
        console.log('发送成功!',event.target.value);
    }, 1000));
```

节省流量,规定时间内只能发送一次请求

核心原理是使用计时来操作

现在的时间减去开始的时间大于间隔时间时进行一次请求,同时注意第一次请求直接发出来

```js
const input = document.querySelector('input')


    function newThrottle(fn, interval) {
      let startTime = 0;
      const _throttle = function () {
        let nowTime = new Date().getTime();
        if ((nowTime - startTime) >= interval) {
          fn();
          startTime = nowTime;
        }
      };
      return _throttle
    }

    let counter=0;
    input.addEventListener('input', newThrottle(() => {
      console.log('循环了'+counter);
      counter++;
    }, 3000))
```

# Vue



## 为什么vue的data属性是一个函数,而不是一个对象

js中对象是一种引用类型,组件是需要复用的,我们希望组件的data属性中的数据是独立的,也就是组件的每一次复用,data都是独立存在的.如果直接使用对象类型,一个组件的data数据改变就会导致其它所有的组件数据都改变

## vue组件通信的方式

1. 父子组件

   1. 使用props $emit

   2. html标签属性是不区分大小写的,也就是在html中使用驼峰法没有意义,可以使用连字符`xxx-yyy`

   3. 父组件传给子组件的props如果子组件没有接收,这种props叫做非props的属性,这些属性会直接添加到子组件的根节点

   4. 使用**$attrs**获取到这些非props的atrribute,在任何地方都可以使用

      ```vue
      Child
      <template>
        <div>
          <div>111</div>
          <div>{{$attrs.test}}</div>  // 111
        </div>
      </template>
      
      Parent
      <template>
        <div>
          <Child test="111"></Child>
        </div>
      </template>
      ```

   4. $emits在vue3中的实例

      ```vue
      Parent
      <template>
        <div>
          <div>计数器:{{count}}</div>
            // 子传父用的是自定义事件,因此这里使用了@
            // add是自定义的事件名称,add是自定义触发时触发的那个方法
            // 子组件拿到的是父组件的自定义的事件名称
          <Child test="111" @add="add" @minus="minus"></Child>
        </div>
      </template>
      <script>
      import {ref} from 'vue'
      
      import Child from './Child.vue'
      export default {
        components:{
          Child
        },
        setup(){
          let count = ref(0)
          // ref的结果是要.value的
          const add=(num)=>{
            count.value+=num
          }
          const minus=(num)=>{
            count.value-=num
          }
          return {
            count,
            add,
            minus
          }
        }
      }
      </script>
      
      Child
      <template>
        <div>
          <div>111</div>
          <div>{{$attrs.test}}</div>
          <button @click="add"> add one</button>
          <button @click="minus">minus one</button>
        </div>
      </template>
      
      <script>
      export default {
          // vue3中声明自定义事件,可以写的更加漂亮
        emits:["add","minus"],
        setup(props,{emit}){
          const add=()=>{
            console.log("chufa");
            emit('add',2)
          }
          const minus=()=>{
            emit('minus',2)
          }
          return {
            add,
            minus
          }
        }
      }
      </script>
      ```

2. 非父子组件

   1. provide与inject

      直接定义并接收使用即可

      ```vue
      provide
      <template>
        <div>
          <Child></Child>
        </div>
      </template>
      <script>
      import {computed} from 'vue'
      
      import Child from './Child.vue'
      export default {
        components:{
          Child
        },
        data(){
          return {
            la:'lalal'
          }
        },
          // 为了使用this获取到data,provide使用了函数式的写法.
        provide(){
          return {
            name:'xxx',
            age:18,
              // 为了让这里的this.la成为响应式的数据,这里引入了computed计算函数来实现响应式
            la:computed(()=>{
              return this.la
            })
          }
        }
      }
      
      inject
      <template>
        <div>
          <div>{{name}}</div>
          <div>{{age}}</div>
          <div>{{la.value}}</div>
        </div>
      </template>
      
      <script>
      export default {
          // 在vue3中可以使用provide与inject函数来通信
        inject:['name','age','la']
      }
      </script>
      ```

   2. 全局事件总线

      vue3中事件总线被第三方库代替

      emit /ɪˈmɪt/ 发射,发送

      on 当...时候

      ```
      eventBus.emit('事件名称',...事件参数)  //要去触发那个事件
      eventBus.on('事件名称')	//一直监听者某个事件是否被触发
      ```

      

## vue2与vue3的区别

ref一定要带上value,一定要带上value

1. 响应式的原理发生改变(两种啊方式对比?)
2. 组件是否支持根元素(是否有fragment的支持)
3. 由选项式API切换为了组合式API 增加可读性与复用性,写起来更加灵活,缺点是相对比较起来难以上手
4. 添加teleport(远距离传送) 与 suspense组件的支持
5. 更好的tree-shaking的支持,原本大量属性绑定在vue实例上,现在全部通过export的方式使用.没有export的方法不会被打包
6. 更好的ts支持
7. 其它源码 层面的更新:更好的diff算法等 

## methods

methods中的函数指定箭头函数时绑定window

## 路由懒加载

components属性可以接受一个函数,该函数返回一个promise来实现路由的懒加载

懒加载可以使当切换到路由映射的路径后才进行加载相应的组件.(本质是利用webpack的分包功能进行分包处理)

## 介绍一下vue的生命周期

在vue3中,没有beforeCreate与created,这一部分的代码直接在setup函数中使用就可以

生命周期把组件的一生从创建到销毁分为了不同的阶段,在不同的创建阶段调用不同的生命周期函数,以便于用户在不同的生命周期阶段注入代码

相比与vue2 vue3改名了最后一个生命周期:beforeunmount unmount

1. beforeCreate

2. 初始化组件实例,但选项对象还没有创建

3. created:这里可以拿到所有写好的数据了 如data,computed,methods等,在这里往往发送网络请求,监听数据($watch)

4. 进行template模板编译

5. beforeMount: 经过编译阶段,将template编译为render函数,此时还没有形成真实DOM

6. 虚拟DOM->真实DOM->DOM挂载

7. mounted: DOM已经渲染完毕,此时可以使用DOM

   1. 如果有数据更新
   2. beforeupdate: 在数据更新以后,DOM被更新之前调用
   3. 根据最新的数据生成新的vnode,然后通过diff算法更新vnode,之后更新真实DOM
   4. updated:在数据更改导致的DOM重新渲染完毕后调用

8. 使用v-if=false等方法导致组件不在进行渲染

9. beforeunmount

10. 将组件vnode从虚拟DOM中移出

11. unmounted(回收操作,如取消事件监听)

    Update写程序可能导致死循环,数据更改->调用updated->又导致数据更改...

keepalive这样的缓存组件是没有create,mount的周期的,要想监听到何时激活该组件

1. activated:激活keepalive组件时触发
2. deactivated:停用keepalive组件时触发

7. beforeDestory
8. 卸载各种各样的实例,方法,指令
9. destoryed

### 有父子关系嵌套时的生命周期:

父亲要想要成功渲染,就需要子组件的成功渲染,因此父亲至少要到达的阶段是beforemount,要渲染还没有渲染的阶段

加载渲染过程

- **父**beforeCreate
- **父**created
- **父**beforeMount
- **子**beforeCreate
- **子**created
- **子**beforeMount
- **子**mounted
- **父**mounted

销毁过程

- **父**beforeDestroy
- **子**beforeDestroy
- **子**destroyed
- **父**destroyed



## 讲一下自定义指令

全局app.directives

## vue2与vue3的响应式原理

何为响应式:即为一个数据的变化,能让网页自动重新渲染并且体现出数据的更新

即数据的改变引起函数的重新执行.哪些函数重新执行?使用到/与那些改变数据有关的函数重新执行

要想知道哪些数据有过更改,就要使用数据劫持

##### 如何监听对象中的属性是否被修改

Object.defineProperty

new Proxy

```js
// 是否是一个响应式函数用一个数组来存放,

const { get } = require("lodash");

// 当响应式数据发生改变时,分别调用数组中的每一个元素
class Depend{
  constructor(){
    this.reactiveFns=[];
  };
  appendFns(fn){
    if(fn){
      this.reactiveFns.push(fn);
    }
    // 添加响应式函数后就执行一次以便于看看初次响应式函数执行的内容
  };
  notify(){
    this.reactiveFns.forEach(value=>{
      value();
    });
  };
};

let obj={
  name:'cheng',
  age:18
};

// 这个对象专门作为这个属性的响应式函数的中心管理工具
let depend = new Depend();
function watchFn(fn){
  depend.appendFns(fn);
  fn();
}

Object.keys(obj).forEach(key=>{
  let value = obj[key];
  Object.defineProperty(obj,key,{
    // 注意这里的set方法只能接收到newValue,没有oldValue哦
    set(newValue){
      value = newValue;
      depend.notify();
    },
    // 没有get方法属性是拿不到的,只能返回undefined
    get(){
      return value;
    }
  })
})

watchFn(function render(){
  // name = name*2;
  console.log(obj.name);
});
watchFn(function render2(){
  console.log('hahahha');
});

// 一旦这个属性发生变化,就调用所有的响应式函数
obj.name="hahah";
```



object.defineProperty是对对象本身的属性进行修改的监听,而proxy通过new一个新的对象,监听新的对象的属性更新

为什么vue3使用proxy?

```js
let newObj = new Proxy(obj, {
      // proxy的target对象就是proxy函数的第一个参数对象
      set(target, key, value, receiver) {
        console.log(target, key, value, receiver);
      },
      // 
      get(target, key, receiver) {
        console.log(target, key, receiver);
      }
    })
```

proxy可以直接监听整个对象,而不是对对象的属性分别进行监听.proxy监听方式是新new出来的对象.proxy多了许多各种拦截方法是defineProperty所不具备的.

## hash路由与history路由

hash路由是利用浏览器地址栏中的hash值的改变来引起页面组件的改变,缺点是会产生一个#,改变hash路由使用window.location.hash

history路由,利用html5中所给的history对象及暴露的API,然后监听location.hash属性是否发生改变

## v-if与v-show的区别

v-show编译DOM代码,只是不会渲染,因为vue为其设置了display:none的属性

v-if直接就没有编译代码,在DOM树上找不到这个元素

## 原理系列

### diff

对比新旧的虚拟DOM,精准的找出差别,并更新对应的真实DOM

1. diff算法只会进行同层对比,(同层对比指的是父节点下的子节点之间的对比.层次深度相同,但不是一个父节点的情况下不会进行同层对比)

流程:

 1. 数据发生改变时,触发数据监听方法中的setter,调用Dep.notify去通知所有的订阅者 watcher,watcher调用patch方法给节点打补丁,也就是进行diff算法

 2. patch方法对比两个节点是否是同一类型的标签(调用sameVnode方法判断),如果是,调用patchVnode进行精细化的比较;如果不是,直接添加用新Vnode生成的DOM进入父节点下,然后删除老节点

    > 所谓同一类型标签,最简单的理解是同一key与同一标签名

 3. patchVnode:

    	1. 判断两个节点是否为同一个节点,是直接return
        	2. 不是,两个节点是否都有文本节点,如果有,将el的文本节点设置为newvnode的文本节点
        	3. 如果oldvn有子节点,新节点没有子节点,直接删除el中的旧的节点
        	4. 如果旧节点没有子节点,新节点有子节点.将新节点转为真实DOM后添加到el节点上
        	5. 如果两者都有子节点,使用updateChildren方法对比子节点

4. updateChildren

   1. 分别在新旧节点添加两个首位指针 oldS oldE newS newE

   2. 依次对比 oldS-newS oldS-newE oldE-newS oldE-newE

   3. 如果存在相同的节点,直接将真实DOM中的节点移动到与newNode中相同节点的对齐位置,然后如果是S--,E++

      ![截屏2021-08-08 下午3.26.25.png](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\d7698f560bb44107911585580c241a99tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)

### 为什么不推荐使用index作为key

原节点:a b c

新节点:xxx a b c 

在diff算法的过程中,首先进行首部节点的对比,这里两个首部节点被认为是同一类型的节点,且两者的文字节点不同,这里直接使用了新节点的文字节点,c节点由于key是4,被当成了全新的节点添加进入DOM,这最终导致整个子节点全部更新,而不是简单的插入xxx节点

因此,我们需要item.id这种独一无二的key,而不是简单的数字作为key

vue的核心系统可以分为三个系统,编译系统,渲染系统,响应式系统.

1. 编译:template语法经过词法分析,语法分析转换成抽象语法树,放入renderer函数中.
2. 渲染:利用h函数生成虚拟DOM,利用mount函数将虚拟DOM转换为真实的DOM,每一次数据数据更新时都进行一次diff算法

```js
// 生成vnode
function h(tag, properties, children) {
  return {
    tag,
    properties,
    children
  }
}

// vnode上树
function mount(vnode, container) {
  const el = vnode.el = document.createElement(vnode.tag)

  // 处理props
  if (vnode.properties) {
    for (const key in vnode.properties) {
      let value = vnode.properties[key]
      if(key.startsWith('on')){
        // 对于事件属性,使用addEventListener来监听
        el.addEventListener(key.slice(2).toLowerCase(),value)
      }else{
        el.setAttribute(key,value)
      }
    }
  }

  // 处理真实DOM的child
  if(vnode.children){
    if(typeof vnode.children==='string'){
      el.textContent=vnode.children
    }else{
      vnode.children.forEach(element => {
        mount(element,el)
      });
    }
  }

  container.appendChild(el)

}
```



# React

## 介绍一下什么是React

前端开发框架,相比较于原生开发,使用react的特点是声明式\组件化\通用性

声明式: 使用return模块的形式?

组件化: 使用组件化来提高复用性,降低耦合性

通用性: react使用虚拟DOM ,这使得react实现了一次书写,处处运行成为了可能

## 为什么React使用JSX

JSX就是js的一种语法扩展,形式类似于xml,通过jsx书写js文件,让js的结构代码可以用标签的形式书写,显著提高了js代码的可读性.

react并不是严格要求使用jsx,当不使用jsx声明元素时,使用react.createElement方法声明.其实,使用了jsx,在编译阶段,babel也会将代码转换为createElement

之所以使用jsx,在于react团队的设计模式,相比于vue的模板语法,react就尽可能的不去引入新的概念,诸如模板指令等在react是找不到的.

# TypeScript

## 为什么使用ts

js这门语言缺少类型检测机制.编程过程中,我们希望尽可能地早发现错误.

IDE帮助我们在代码编写阶段发现错误

类型检测帮助我们在编译阶段发现错误而不是在运行阶段

而TS就能弥补js在类型检测上的空白

除了类型检测,ts还添加了许多的新特性

# Webpack

## Loader与Plugin

定义:

loader用于将不同的模块转换为webpack可以识别的模块

webpack原生只能识别诸如js\json这样的模块,loader赋予了webpack识别css等模块的能力

loader的基本执行顺序是从下到上,可使用配置项来改变执行的顺序

### 手写loader

loader本质是一个函数,当webpack在编译到某个指定的文件格式时,就调用loader函数,并且把要编译的内容传给这个函数.

由此可见loader就是一个函数中转站,拦截你写的文件进行进一步的处理以便于webpack正确识别它原本不能识别的文件

```js
module.exports = function loader(content){
  return content;
}

// content内容就是 console.log(hello worlde)
// 因此控制台上输出就是hello world!
```



## 基本构建形式

```js
var path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  // 生产模式代码会被压缩
  mode: 'development',
  entry: './src/main.js',
  devServer:{
    static:{
      directory:path.resolve(__dirname,'dist')
    }
  },
  module:{
    rules:[
      {
        test:/\.(jpe?g|gif|png)$/,
        use:{
          // loader:'file-loader',
          loader:'url-loader',
          options:{
            name:'[name].[ext]',
            outputPath:'img/',
            limit:20480
          }
        }
      },
      {
        test:/\.css$/,
        // 注意此处的写法
        use:['style-loader','css-loader']
          //一个用来处理依赖关系,一个用来处理样式
      },
      {
        test:/\.m?js$/,
        exclude:/(node_modules)/,
        use:{
          loader:"swc-loader"
        }
      }
    ]
  },
  plugins:[
    new HtmlWebpackPlugin({
      template:'public/index.html'
    })
  ],
  output: {
    path: path.resolve(__dirname, 'dist'),
    // filename: '[name].[contenthash:6].js',
    filename:'[name].js'
    // hashFunction:'xxhash64'
  }
};
```



## 优化构建速度

首先考虑到loader,loader是用来识别不同的格式进行转换的,

精简处理:

include,exclude约束执行范围,排除一部分不需要执行的

不重复处理(缓存):

模块解析以后,进行一次缓存,下次再次使用该模块时,直接使用缓存即可.配置方法:

```
module.exports={
	cache:{
		type:'filesystem'
	}
}
```

一条线处理的更快(高效编译器):

使用SWC或者ESBuild等更快的编译器

并行处理:

使用官方推出的thread-loader(多进程解决方案),这个一个loader,安装后把这个loader放置在所有loader的最前面即可.

但注意的是,由于创建进程也需要时间,该方法的处理效果并不理想



## 实现更好的性能优化

使用swc-loader转化js,替代babel

```
{
        test:/\.m?js$/,
        exclude:'/(node_modules)/',
        use:{
          loader:"swc-loader"
        }
      }
```

## npx命令

npx就是直接执行本地/node_modules/.bin下的命令,免去了在scripts里写东西的麻烦



# 性能优化与浏览器原理与计算机网络

## 输入URL浏览器发生了什么 

### TCP连接过程

1. 用户输入URL地址,浏览器发送给DNS服务器,DNS服务器经过解析返回给浏览器服务器的IP与端口号
   1. 查找DNS并不是直接向DNS服务器寻找,先向浏览器缓存中寻找,再向操作系统缓存中寻找,再不行向hosts里寻找
   2. 本地DNS->根DNS->顶级DNS->权威DNS
2. 浏览器通过三次握手与服务器建立TCP连接
   1. 客户端发送SYN包,服务器收到SYN包 
   2. 服务器发送ACK包,客户端收到ACK包 (客户端发送与接收的功能正常)
   3. 客户端发送ACK包,服务器收到ACK包 (服务器确认发送与接收功能正常)
3. 建立TCP连接以后,浏览器按照HTTP规定格式通过TCP向服务器发送"GET /HTTP/1.1"报文
4. 服务器收到报文后,根据HTTP协议解析报文,了解到浏览器的请求内容.了解到具体内容之后,根据HTTP协议拼接成符合要求的报文发送回去,此时发送回去的即为响应头为"HTTP/1.1 200 OK"的响应报文
   1. 收到报文的时候,服务器会在TCP层面返回一个ACK包确认请求,不过该包HTTP是看不到的
5. 浏览器收到报文进行解析,如果是个HTML文件,再通过浏览器引擎,JS引擎进行解析渲染.
   1. 在TCP层面,浏览器也要返回一个ACK确认响应报文收到了
6. TCP四次挥手
   1. 客户端发送FIN包,服务器接收到FIN包
   2. 服务器发送ACK包,客户端接收到ACK包,客户端改变状态,等待服务器的断开信息
   3. 服务器发送FIN包,告诉客户端现在可以断开连接了.客户端接收到FIN包
   4. 客户端发送ACK包给服务器,服务器接收到ACK包,然后断开连接.如果客户端等一段时间后还没有收到服务器发来的信息,说明链接已经中断了.


### 进程与线程

线程是跑在进程里面的.一个进程里面可以有多个线程,一个线程只能对应一个线程

打开一个应用程序就相当于打开一个进程(浏览器中一个页面就是一个进程),系统将会为该进程分配一个全新的内存空间

创建进程以后,就可以创建线程来进行任务处理.可以创建多个线程来处理多个任务.同时处理多个任务的方式就叫做并行处理.

在应用程序中,可以创建新的进程进行资源处理,由于进程之间是相互独立的,使用新的进程可以避免一个进程挂掉以后,依然可以使用其它进程.

#### 在Chrome浏览器中

市面上大部分浏览器都是采取了多进程设计,如浏览器进程,渲染进程,GPU进程,插件进程.每个进程担任不同的角色.处理不同的任务.每个进程下有细分了许多的线程,处理该进程下更加细分的小人物.不同进程之间是相互隔离的.

```
理解用:
当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候Browser Process会向这个URL发送请求，获取这个URL的HTML内容，然后将HTML交给Renderer Process，Renderer Process解析HTML内容，解析遇到需要请求网络的资源又返回来交给Browser Process进行加载，同时通知Browser Process，需要Plugin Process加载插件资源，执行插件代码。解析完成后，Renderer Process计算得到图像帧，并将这些图像帧交给GPU Process，GPU Process将其转化为图像显示屏幕。 即 标签页是渲染进程
```

Chrome浏览器是一个多进程程序,它主要包括

浏览器进程(Browser Process)

渲染进程(Renderer Process)

插件进程(Plugin Process)

GPU进程(GPU Process)

打开浏览器时会启动一个browser process,输入URL请求时会开启一个渲染进程(renderer process)

#### 渲染进程

渲染进程主要负责浏览器请求到html等代码后的解析与渲染工作,

它包括GUI线程,JS引擎线程,事件触发线程,定时器线程等

GUI线程就是走的关键渲染路径,通过构建dom tree css tree renderer tree 布局\绘制 重绘与回流的步骤,完成网页的渲染.

JS引擎线程主要负责解析js代码(v8引擎),其与GUI线程互斥,即会堵塞GUI线程的正常解析

事件触发线程:(event loop核心线程)触发的事件放入队列的尾部等待js引擎处理

所以为什么script会影响js解析,script属于js引擎线程,解析属于GUI线程,两者是互斥的.

### 浏览器渲染原理(关键渲染路径)

其实这一部分就是性能优化问题

浏览器渲染就是利用浏览器内核,也就是利用浏览器渲染引擎进行渲染

#### 构建DOM树

首先浏览器在请求资源时,往往服务器会优先返回index.html静态资源,浏览器拿到资源后,会进行词法分析与语法分析,构建一个DOM Tree,如此,DOM中的每一个节点都变为了可以被js操作的对象.

#### 样式计算

##### 1.转换结构

现在页面有哪些元素浏览器知道了,元素的样式是什么样浏览器还不知道.

在这个过程中,如果遇到link这样的标签,会进行异步请求css资源.或遇到内联样式或行内样式

浏览器对于这一部分的代码进行转换成css dom,可以在document.styleSheets里看到这个对象

##### 2.属性值标准化

现在有哪些样式浏览器已经知道了,然后浏览器还会进行样式的标准化,标准为便于浏览器理解的单位

##### 3.计算具体的样式值

首先样式值要受到css的继承特性的影响,继承就是子元素继承父元素的属性.

具体继承的方式在devtools可以看到

之后根据css中的层叠特性 最终计算完成的效果可以在computed面板中看到

##### 4.布局

经过之前的几个步骤,已经知道有哪些元素以及元素的样式信息,但还不知道位置信息,布局解决这个问题

###### (1)创建布局树(render tree)

根据DOM Tree与CSS Tree,生成所有需要渲染的元素,也就是render tree(不包括不需要渲染的元素如<header>,或者display:none的元素)

###### (2)布局计算

这里就可以进行计算布局了,但注意只是计算一下位置,并没有真正的渲染出来

经过以上的学习,我们可以看到要想页面能够迅速的渲染出来,优化html与css的体积是必要的,同时也要注意扁平化css选择器,也就是尽量避免css tree生成时的递归调用.

除此之外,script标签会阻塞html的解析,这就是为什么script标签会放到文件的最后面的原因.

使用defer可以允许script

#### 回流与重绘

浏览器根据render tree确认了需要渲染那些元素以及元素的样式与位置,开始渲染

回流:

render tree中部分或全部元素发生大小,结构或属性改变时,浏览器重新渲染部分或者全部文档内容叫做回流

重绘:仅仅改变元素的样式,并不改变元素在文档流中的位置.,这种情况下会引起重绘

回流必然导致重绘,重绘不一定会导致回流. 回流是元素位置的改变,重绘是元素样式的改变

在 HTML 页面内容被提交给渲染引擎 之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计 算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存 在布局树中。

##### 利用回流与重绘改善性能

布局结束后,并没有立即绘制画面,而是针对特定的布局树节点进行分层.



## 浏览器缓存

缓存是一种简单直接地性能优化方法

### 

## Web存储

### cookie

由于HTTP是一种无状态协议,也就是建立连接,交换数据,断开连接这一过程后,再次发起请求,服务器并不知道客户端的身份.于是cookie应运而生,cookie是浏览器存储在本地的文件,用于下次客户端发送请求时告知服务端身份

修改cookie的api document.cookie

1. cookie被借用了存储的功能 
2. 大小限制在4KB
3. 每次都会携带在http头中，过量的cookie会损耗性能。
4. cookie是紧跟域名的，同一个域名下的所有请求，都会携带 Cookie。
5. 不够安全，服务器没法分辨用户和攻击者，攻击者可以读取网络上的其他用户的信息，包含HTTP Cookie的全部内容，以便进行中间的攻击。使用跨站点脚本技术可以窃取cookie等。

### WebStorage

1. 大小为5MB
2. 只发生在浏览器本地,不与服务器进行交换

## TCP/IP协议

### TCP与UDP的区别

1. TCP需要连接,UDP不用连接,直接传输数据
2. TCP是一对一的两点服务,UDP支持一对一与一对多
3. TCP是可靠交付,数据无差错,不丢失.UDP不保证可靠交付
4. !!(非必要不用回答)TCP有拥塞控制和流量控制,保证数据传输安全性.UDP没有,可以保证传输的效率
5. TCP面向:HTTP/FTP.UDP面向视频,音频等

## HTTP协议

五层模型:应用层HTTP 传输层TCP UDP 网络层IP 链路层 物理层

http是一种网络协议,解决了应用程序之间如果传输数据,应该以怎么样的格式传输数据的问题.

其底层基于TCP/IP协议,该协议解决了应用程序之间如何建立通信连接,以及如何通信的问题.

特点:

1. 可扩展:请求响应头,请求方法,状态码等都可以灵活拓展,这些都是随着时代发展所添加上去的.
2. 可靠传输:HTTP基于TCP/IP协议,TCP本身是一种可靠传输协议,本质是对传输的数据做上一层包装(加上一些头信息)然后利用socket API发送.可靠的就是信息能过正确的送达
3. 请求应答模式:顺序进入,顺序出去.一个请求,一个应答
4. 无状态:收发双方不知道对方的身份每一次的报文传输也是完全独立的.TCP协议就是有状态的,UDP不是
   1. 无状态可以减轻服务器记忆状态的负担,还可以不用任何判断的进行负载均衡实现高并发

5. 明文传输:截获的流量就是真实浏览的内容
6. 性能: 请求应答模式导致的队头阻塞,即顺序发送的请求如果遇到堵塞,后面排队的请求也会一并被堵塞

实体数据:  

浏览器接收到HTTP数据后,并不知道该数据是什么样的格式,于是规定MIME.同时传输数据存在压缩,规定Encoding Type

1. MIME,规定HTTP的数据类别 type/subtype 
   1. 对应请求头:Accept 响应头:Content-type 这个过程叫做内容协商
   2. text image audio video application
2. Encoding-type:gzip deflate br
   1. 对应 accept-encoding content-encoding
3. 其它编码格式,语言等也属于内容协商
   1. 使用q=value设置权重

长短连接:

1. 短连接每一次都要TCP连接,太浪费
2. 长连接(默认开启)
   1. 请求/响应头:Connection:keep-alive
3. 解决对头阻塞的问题,使用并发连接,也就是对同一个域名开启多个长连接,但这回造成服务器资源的问题

重定向: 301与302状态码等可以认为是重定向

​	1.重定向的地址有响应头:Location:/xxx.html决定

Cookie: 为了解决HTTP无状态的问题,使用cookie让服务器记住状态,除此之外,还有广告跟踪的功能(第三方cookie)

	1. 响应头Set-cookie,发给客户端,
	1. 客户端下次再请求时,使用cookie请求头,标明自己的身份
	3. cookie的属性
	 	1. expires与max-age(max-age的优先级更高):设置cookie的失效时间
	 	2. domin;path指定cookie所属的域名和路径,在发送cookie前,浏览器对比URL中的域名与路径是否与cookie中的一致,如果一致再发送请求.
	 	3. HttpOnly属性:只能通过http协议传输cookie,防止了XSS攻击(防止了诸如document.cookie的方法获取cookie)
	 	4. SameSite属性:SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送， 而“SameSite=Lax”允许 GET/HEAD 等方法，但禁止 POST 跨站发送。这防止了CSRF攻击,即如果跨站传输cookie的话会被禁止

### HTTP缓存

强缓存:在资源未过期之前.浏览器都不会向服务器请求资源,直接使用本地的缓存

主要响应头: expires cache-control

1. cache-control:max-age:5 这里的时间是从**报文创建的时间开始计算的**.即为Date字段
2. no-store:不存储缓存,用于数据变化非常频繁的数据,如秒杀界面
3. no-cache:使用缓存之前向服务器验证是否过期,不管缓存有没有过期
4. must-revalidate:如果缓存过期了,就向服务器校检,没过期直接用就可以了

![image-20221116200246630](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221116200246630.png)

​	5. 请求与响应都可以实现cache-control,如果请求头里添加了max-age=0,也就是缓存资源保存0s,也就相当于no-store.即服务器每次都要返回最新的资源

协商缓存:每一次都需要与服务器进行协商查看资源是否有更新,如果更新就重新获取资源,返回200.没有命中缓存,返回304

请求头:if-modified-since if

代理服务器

区分代理服务器↓

代理服务器作为客户端与服务器中间的中间人,一定程度上隐藏了服务器的真实信息1. 使用via字段,每次经过代理服务器时,都添加:via:proxy1,proxy2这样的字段

源服务器的缓存控制

1. private只能缓存在客户端,publlc缓存完全开发
2. 如果你登录论坛,返回的报文里set-cookie里有论坛ID,这个时候就不能再使用代理服务器缓存,只能存在客户端,否则就有泄露的风险
3. proxy-revalidate,缓存过期后,只验证到代理服务器这个级别就可以了
4. s-maxage,设置缓存在代理服务器上的缓存时间
5. no-transform:禁止代理服务器偷偷的改变一些数据

![image-20221116204510957](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221116204510957.png)

### HTTP状态码

响应报文中的响应头分为: HTTP版本号 状态码 原因(基本无用)

1. 1XX:表示处于通信的中间阶段,还需要继续操作

   101 Switching Protocols: 客户端通过Upgrade请求头告知更换请求协议,服务器同意更换,返回101状态码告知客户端更换协议

2. 2XX:表示服务端受到并成功处理了客户端的请求

   200 OK:正确的处理了请求

   204 Not Content:正确的处理了请求,但没有响应体

   206 Partial Content:客户端发送部分请求,要求获得部分资源,服务器返回的响应体只是一部分的情况.响应体中还有content-range的响应头,用于标记响应数据的大小

3. 3XX:表示客户端请求的数据发生变动,必须以新的URI发送请求

   1. 301 Moved Permanently:永久重定向,即资源不存在,需要改用新的URI
   2. 302 Found 临时重定向:资源临时不存在
   3. 304 Not Modified 用于浏览缓存,可以理解为:重定向到已经缓存的文件上
   4. (以下非常用)303 307 308


## HTTPS

http是明文传输,使用它来传输非常的不安全

https相比较http最大的变化就是下层协议变成了SSL/TLS

TLS是它的正式姓名,SSL只是习惯叫法

![image-20221115204258145](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221115204258145.png)

### 对称加密与非对称加密

1. 加密和解密的密钥都只是一个  

   在TLS中,常用的加密算法是:AES与ChaCha20

2. 公钥发给任何人,私钥只能自己保管

   常用的加密算法是: RSA 与 ECC

### 在TLS中使用的是混合加密

1. 首先使用非对称加密,解决密钥传输问题
2. 生成一个会话密钥,使用公钥加密这个会话密钥,发给接收方,接收方使用私钥解密,就完成了会话密钥的传输
3. 之后的方法就是用对称加密

### 摘要算法

混合加密并不能完全保证安全,摘要算法是为了保证消息的完整性

发送消息给服务器时,带上一个SHA-2的摘要,网站收到信息后计算摘要,然后进行对比.如果一致即说明消息完整.(注意要把消息与摘要通过会话密钥同时加密,防止摘要也被修改)

### 数字签名

数字签名存在的目的是保证双方的**身份认证**信息

数字签名的原理就是将非对称加密的原理返回来,以前是公钥加密,私钥解密.现在是私钥加密,公钥解密

通过私钥加密传输密文的摘要后的内容即为数字签名

浏览器通过自己的私钥加密发送给服务器的信息的摘要,服务器通过公钥解密后发现和接收的内容的摘要一致,服务器就确认了浏览器的身份信息.反过来也一样

### 数字证书认证机构(CA)

公钥任何人都有,可是怎么确定这个公钥就是某个网站公开的呢?使用CA

CA完整的证明了公钥的所有者信息,形成了数字证书

数字证书的级别: DV <OV< EV,在于数字证书的可信程度

CA证明自己的方法:根证书

## HTTP2

HTTP2相比较1,在规范上没有太大的变化,保留了协议名:http/https,这很好的保证了网站的兼容性

1. 头部压缩: 

   1. http1时期,通过content-encoding字段指定body的压缩格式,但是header的大小与内容依然很多 .使用HPACK算法进行头部压缩

2. 二进制格式

   由明文转换为二进制格式,把原来的“Header+Body”的消息“打散”为 数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放 实体数据。

3. 流

   对往返的消息分配一个唯一的流ID,这样数据帧有了先后顺序,就可以正确的组成请求与响应把报文

   如此,流可以发送多个帧序列,也就是多路复用,

   改变请求响应的应答模式,服务器也可以主动的发送流给客户端,这叫做服务器推送

4. 强化安全

   在实际的应用场景上HTTP2就是使用https

## 网络安全

### XSS攻击

Cross Site Scripting(跨站脚本),即进行

就是尽可能的把可执行代码嵌入到网站中执行

持久型:把代码直接注入到数据库中,这么做可能危害到所有的网站使用用户

举例:评论区内输入`<script>alert('hhh')</script>`这样的

非持久型:通过浏览器传参来注入代码

解决方案:

将用户输入的内容进行改变,防止用户输入不该输入的内容

1. 字符替换(将可能的攻击字符转换成没有攻击可能的字符)
2. 使用白名单过滤(白名单中标明只接受哪种类型的标签) 请见 js

### CSRF攻击

跨站请求伪造,黑客编写一个请求代码,诱导用户的点击或在用户不知情的情况下发起请求,如果后端没有相应的防御措施,就会误以为是用户真正的发送了请求,造成用户隐私泄露;

解决方案:

1.验证referer: 验证站点请求来源,如果来源不为本站点,则后端拒绝请求;

2.验证token: 每次访问时,服务器下发一个token,进行请求时,浏览器携带token与服务器进行认证,如果认证通过就允许请求



# 算法

## 链表

### 206.反转链表

1.要反转就要改变链表指向,要改变指向,就要涉及到前后两个指针.

2.当前current指针即为head,pre指针在head的前面,也就是null了

3.当pre指针指向最后一个元素,此时current指针指向了空,循环结束,pre成了头指针.返回pre即可

```js
  let pre = null;
  let current = head;
  let temp=current.next;
  while (current) {
    current.next = pre;
    pre=current;
    current = temp;
    temp = current.next
  }
  return pre
```

## 字符串

### 344.反转字符串

1. 字符串的反转最简单的方式就是前后两个元素互相交换位置
2. 当两个指针指向同一个元素或者l指针比r指针还要快的情况下停止反转

```js
var reverseString = function(s) {
    let l=0
    let r=s.length-1;
    let temp;
    while(l<r){
        temp=s[l]
        s[l]=s[r]
        s[r]=temp
        l++
        r--
    }
    return s
};
```

### 541. 反转字符串II

1. 将字符串每两段两段的划分可以通过for循环的最后一个选项

2. 更改字符串的一个重要方法就是将字符转为字符数组,单纯的更改字符串并不好实现

   

```js
var reverseStr = function (s, k) {
    // 通过split方法转换为字符数组
    let arr = s.split('')
    for (let i = 0; i < arr.length; i = i + 2 * k) {
        // 即大于k个元素,反转前k个.不到k个元素,全部反转
        // 反转元素左闭右开
        if ((i + k) <= arr.length) {
            reverse(arr, i, i + k)
        } else {
            reverse(arr, i, arr.length)
        }
    }
    // 通过join方法将数组字符转为字符串
    return arr.join('')
};

var reverse = function(arr,start,end){
    let l=start;
    let r=end-1;
    let temp;
    while(l<r){
        temp = arr[l]
        arr[l]=arr[r]
        arr[r]=temp
        l++
        r--
    }
    return arr
}
```



### 剑指Offer 05.替换空格

直接API法,注意replace返回的新的字符串,并且接收的是一个正则

```
var replaceSpace = function(s) {
    let newStr = s.replace(/ /g,'%20')
    return newStr
};
```

不使用API时,

### 重复的子字符串

利用滑动窗口,指定一个字符串个数,多次重复,,看看是否与想要的字符串相等

```js
var repeatedSubstringPattern = function(s) {
    let len = s.length;

    let step = 1;
    let initStr = s.substring(0, step);
    while(step <= len / 2) {
        if(initStr.repeat(len / step) === s) {
            return true;
        }
        step++;
        initStr = s.substring(0, step);
    }

    return false;
};
```



## LRU缓存

最新最近的缓存是有用的,老的缓存是没有用的

解释案例就是浏览器地址栏的地址保存方式

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.capacity=capacity;
    this.cacheMap = new Map();
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    cacheMap = this.cacheMap
    if(cacheMap.has(key)){
        let value = cacheMap.get(key)
        cacheMap.delete(key)
        cacheMap.set(key,value)
        return value
    }else{
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    cacheMap = this.cacheMap
    if(cacheMap.has(key)){
        cacheMap.delete(key)
        cacheMap.set(key,value)
    }else{
        if(cacheMap.size>=this.capacity){
            cacheMap.delete(cacheMap.keys().next().value)
            cacheMap.set(key,value)
        }else{
            cacheMap.set(key,value)
        }
    }
};
```



## 手写快速排序

快速排序的核心原理:

选择一个基准值,(一般为最左边),从最右边开始放置一个指针,一次向左边对比大小.如果左边的大于右边的,置换.

置换后,**基准值依然不变**,指针继续向前移动.第一轮排序完成后,基准值在指定的位置不动,把数字分成左右两部分.再进行下一次的置换.

```
// 注意这里小知识点;
// 数组里面的元素不是引用类型,赋值给新的变量后,新的变量就永久的得到了这个值
// 数组是引用了类型,数组的元素不是引用类型

let arr=[1,2,3,4]
let pivot=arr[0];
pivot=4;
console.log(arr);
```



```js
// 挖坑填数与分治法
// 选到的基准值就是挖下的坑位,左边有坑位就用右边的指针来找数填坑,右边有坑位就用左边的指针找数填坑
// 通过计算到mid,在进行分治就容易了
// 注意分支时各个区间的范围,是不包含mid的
let arr = [5, 1, 3, 4, 8, 2];

function getMid(arr,left,right){
  let pivot = arr[left];
  let l = left;
  let r = right;
  while (l < r) {
    while (arr[r] >= pivot && l < r) {
      r--;
    }
    if (arr[r] < pivot) {
      arr[l] = arr[r];
      l++;
    }
    while (arr[l]<=pivot && l<r){
      l++;
    }
    if(arr[l]>pivot){
      arr[r] = arr[l];
      r--;
    }
  }
  arr[l] = pivot;
  return l;
}

function quickSort(arr,left,right) {
  if(left<right){
    let mid = getMid(arr,left,right);
    quickSort(arr,left,mid-1);
    quickSort(arr,mid+1,arr.length-1);
  }
  return arr;
}

let newArr = quickSort(arr,0,arr.length-1);
console.log(newArr);
```

## 二分查找

举例:查找数组中是否具有哪一个元素

二分查找的前提是**数组无重复元素且数组有序**,因为一旦有重复元素,查找返回元素的下标可能不唯一

二分查找要定义好区间,按照定义好的区间进行查找,比如查找到的区间必须是左闭右开

```js
var search = function (nums, target) {
  let l=0;
  let r=nums.length-1;
  let middle;
  let mValue;
  while(l<=r){
    middle = Math.floor((l+r)/2);
    mValue = nums[middle];
    if(mValue===target){
      return middle;
    }
    if(mValue<target){
      l=middle+1;
    }else{
      r=middle-1;
    }
  }
  return -1;
};
```

## 为字符串添加千位分隔符



## 移除数组元素

数组的删除不是直接删除的,数组在内存中是一段连续的地址,删除一个元素后,后面的元素都需要向前进一位补齐删除后的空位.

### 暴力法

```js
for(let i=0;i<nums.length;i++){
    if(nums[i]===val){
      for(let j=i+1;j<nums.length;j++){
        nums[j-1]=nums[j];
      }
      // 指针再给我回去,防止后面的数字跟上来删除不掉
      i--;
      nums.length--;
    }
  }
  return nums.length;
```

### 快慢指针法

核心在于要删除元素,不删除,所有不该删除的保留下来,该删除的用后面不该删除的覆盖掉.

```js
let slow=0;
  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] !== val) {
      nums[slow] = nums[fast];
      slow++
    };
  }
  return slow;
```

# 项目

## 低代码项目

### 封装基础组件的方法

封装基础组件主要是让组件的功能可以自定义拓展,

1. 组件分为index.js与console.js,分别封装组件本身以及组件控制台,组件本身就是利用antv给的api,当用户添加组件时,就利用redux给的默认值填补组件参数.
2. 控制台控件,通过监听控件的事件,事件触发,就更新redux中的domList状态,状态更新引起页面的重新渲染

### 组件拖拽的实现

为要托拖拽的元素设置draggable属性,当开始拖拽时,触发onDragStart事件,传入组件的id给drop组件接收,

## 后台管理项目

## 长列表的展示方案

### 虚拟列表

虚拟列表把列表分为了两部分,可视部分进行渲染,非可视部分不进行渲染或者部分渲染(缓冲区)

## 页面直接传参的方法

1. 如果有两个页面，比如说点击a商品出现详情页，怎么传递数据

   1. url传递参数：

      1. 传参：

         ```javaScript
         //一个变量
         url = "http://www.baidu.com?data=123"+
         url = "http://www.baidu.com?data="+data
         //多个变量
         url = "http://www.baidu.com?data=123&data2=321"
         url = "http://www.baidu.com?data"+data+"&data2"+data2
         ```

      2. 接参：window.location对象包含了浏览器地址栏URL的相关数据,通过`location.search` 获取到传入的参数值(?data=123&data2=321)，再对字符进行处理取参

   2. cookie：`document.cookie` 

   3. localStorage：

   4. vue的路由传参：

      1. query：

         ```javaScript
         //传参
         import { useRouter } from 'vue-router';
         const router = userRouter();
         router.push({
         	path: '/info',
         	query: {
         		name: name,
         		id: id,
         		price: price
         	}
         })
         //接参
         import { useRoute } from 'vue-router';
         const route = useRoute();
         route.query.id
         ```

      2. params：

         ```javaScript
         //传参
         router.push({
         	name: 'info',//配置path无效
         	params: {
         		name: name,
         		id: id,
         		price: price
         	}
         })
         //接参
         route.params.id
         ```

      3. 动态路由传参

         ```javaScript
         //配置路由时
         {
         	path: '/info/:id'.
         	name: 'info',
         	component: info
         }
         //跳转事件
         //router.push('/info/' + id);
         //或
         router.push({
         	name: 'info',
         	params: {
         		id: id
         	}
         })
         //接参
         route.params.id
         ```

         区别：

         1. query传递的参数会显示在地址栏中，而params不会；
         2. query传参刷新页面数据不会消失，params会；
         3. 基于params的动态传参，数据会显示在地址栏中，且刷新页面不会消失。

   5. iframe+onmessage

# 场景面试

## 2022/8/27 百度一面

```arduino
提前批-53min
```

项目同时用到React和Vue，是为啥？

Taro和原生区别，或者说Taro缺点

Taro的性能优于原生？

有了解过JS引擎里面的一些详细实现逻辑？

简单说下JS的作用域

局部作用域var声明的变量会提升到全局作用域吗

说一下JS的数据类型

ES6中你常用的语法

箭头函数和普通函数区别是啥？

除了this指向，还有啥区别

Linux中，怎么查看当前目前下的所有文件，包括隐形目录

V8引擎垃圾回收机制？

CSS选择器优先级

盒子模型了解过吗

你nginx部署遇到过哪些问题？

你简单和我说一下反向代理，你理解的反向代理

反向代理除了解决跨域，还有啥作用

负载均衡了解过？

分发的行为称为啥？

设计全链路的登录模块，你会怎么设计，包含前后端和数据库

token怎么生成

密码放token中吗

时间戳还有其他目的吗

jwt是后端生成的吧

原生小程序遇到哪些坑吗？

怎么做的响应式

那有了解它这块具体怎么做的响应适配吗

rpx，底层代码实现的响应式(没回答上来)

移动端布局，有了解吗？

移动端布局如何做到设计稿的高还原度

这几个项目哪个对你挑战最高，学到的东西最多

做项目，接触一门新技术，会怎么学习

第三个项目总结有个页面设计合理性……，能说一下项目中的case

你经常写CSDN吗？

怎么访问谷歌，是搭梯子吗？

项目中，是单独负责项目，还是负责整个项目

从系统设计宏观层面介绍项目，哪个最了解的

系统的设计，业务模块，模块间的关系

了解过项目管理吗

讲一下你了解的项目管理

拿出实施计划后，后面会有闭环反馈吗

有项目总结吗？团体性的总结

明年毕业，没错吧？

公司一个新需求，到交付，角色分别是？他们的职责？

webstorm用的正版吗？

算法：手写二分

了解过nodejs吗

反问

部门技术栈

产品

对部门氛围和工作的感受

字节跳动前端实习面经                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

​                                                                                                      发布于  11-16 11:06                                                                                                          

​                    1.自我介绍
(我记错时间迟到了，但是面试官很好，让负责的小姐姐给我打电话了)
2.项目，因为面试的岗位里面有要求是小程序开发经验，就说了一下，应该是深挖项目
3.uniapp怎么运行到小程序实现的底层原理
4.vue组件通信，我说了props和自定义事件
5.然后问了组件通信里面跨级怎么处理
6.问了一个js的东西，没听清，好像没听说过(菜鸡真的不知道是什么
7.promise,讲一下和setTimeout区别，实现
8.实现深拷贝，面试官给了例子，补全代码就好
9.网络通信这一大块，发送请求怎么进行，主要有哪几种，然后我说主要有get和post，顺势就问了我这两个有什么区别
10.我提到了跨域问题，就问了跨域这一块
11.js基本数据类型，然后object和number区别(答了堆和栈，他说还有

   差不多这些吧，面试体验很好，面试官一直在和我讲底层实现原理，还有网络底层以及js底层，大部分没背过，根据自己的判断说出来了，大概答上来百分之五十吧，没有算法题，就是挖技术。
    最后问了一下他对我的印象和建议(社恐人大胆尝试)，说我多学习学习可以继续投没问题

2022 11-24 第一次面试 

1. 箭头函数与普通函数的去比
2. vue data为什么是一个函数返回一个对象?为什么不是直接的一个函数
3. 了解过vue的源码吗?
4. 说一下vue的组件传参方式
5. v-if与v-show的区别
6. DOM操作发生在生命周期的哪一个阶段
7. 有没有碰到过对象里面嵌套着另外一个对象,层层嵌套后修改对象属性不生效的问题

# 简历



小吴第一次面试

技术栈稍有缺失



<img src="C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221028102728626.png" alt="image-20221028102728626" style="zoom:50%;" />

项目经历没什么可问的

<img src="C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221029162216984.png" alt="image-20221029162216984" style="zoom:50%;" />

北方银时 技术栈进行精简,有部分内容是可以合并的

![image-20221103215319282](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221103215319282.png)

🐓

![image-20221110190146067](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221110190146067.png)

🐏

<img src="C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221110191701455.png" alt="image-20221110191701455"  />

<img src="C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\Screenshot_2022-11-05-21-53-24-02_31f8a70043d0707.jpg" alt="Screenshot_2022-11-05-21-53-24-02_31f8a70043d0707" style="zoom:50%;" />

大三字节实习生同学面试实录，预测毕业25k大厂起步

![image-20221118231738762](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221118231738762.png)
