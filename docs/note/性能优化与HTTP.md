---
layout: doc
---

# 性能优化与浏览器原理与计算机网络

## 输入URL浏览器发生了什么 

### TCP连接过程

1. 用户输入URL地址,浏览器发送给DNS服务器,DNS服务器经过解析返回给浏览器服务器的IP与端口号
   1. 查找DNS并不是直接向DNS服务器寻找,先向浏览器缓存中寻找,再向操作系统缓存中寻找,再不行向hosts里寻找
   2. 本地DNS->根DNS->顶级DNS->权威DNS
2. 浏览器通过三次握手与服务器建立TCP连接
   1. 客户端发送SYN包,服务器收到SYN包 
   2. 服务器发送ACK包,客户端收到ACK包 (客户端发送与接收的功能正常)
   3. 客户端发送ACK包,服务器收到ACK包 (服务器确认发送与接收功能正常)
3. 建立TCP连接以后,浏览器按照HTTP规定格式通过TCP向服务器发送"GET /HTTP/1.1"报文
4. 服务器收到报文后,根据HTTP协议解析报文,了解到浏览器的请求内容.了解到具体内容之后,根据HTTP协议拼接成符合要求的报文发送回去,此时发送回去的即为响应头为"HTTP/1.1 200 OK"的响应报文
   1. 收到报文的时候,服务器会在TCP层面返回一个ACK包确认请求,不过该包HTTP是看不到的
5. 浏览器收到报文进行解析,如果是个HTML文件,再通过浏览器引擎,JS引擎进行解析渲染.
   1. 在TCP层面,浏览器也要返回一个ACK确认响应报文收到了
6. TCP四次挥手
   1. 客户端发送FIN包,服务器接收到FIN包
   2. 服务器发送ACK包,客户端接收到ACK包,客户端改变状态,等待服务器的断开信息
   3. 服务器发送FIN包,告诉客户端现在可以断开连接了.客户端接收到FIN包
   4. 客户端发送ACK包给服务器,服务器接收到ACK包,然后断开连接.如果客户端等一段时间后还没有收到服务器发来的信息,说明链接已经中断了.


### 进程与线程

线程是跑在进程里面的.一个进程里面可以有多个线程,一个线程只能对应一个线程

打开一个应用程序就相当于打开一个进程(浏览器中一个页面就是一个进程),系统将会为该进程分配一个全新的内存空间

创建进程以后,就可以创建线程来进行任务处理.可以创建多个线程来处理多个任务.同时处理多个任务的方式就叫做并行处理.

在应用程序中,可以创建新的进程进行资源处理,由于进程之间是相互独立的,使用新的进程可以避免一个进程挂掉以后,依然可以使用其它进程.

#### 在Chrome浏览器中

市面上大部分浏览器都是采取了多进程设计,如浏览器进程,渲染进程,GPU进程,插件进程.每个进程担任不同的角色.处理不同的任务.每个进程下有细分了许多的线程,处理该进程下更加细分的小人物.不同进程之间是相互隔离的.

```
理解用:
当我们是要浏览一个网页，我们会在浏览器的地址栏里输入URL，这个时候Browser Process会向这个URL发送请求，获取这个URL的HTML内容，然后将HTML交给Renderer Process，Renderer Process解析HTML内容，解析遇到需要请求网络的资源又返回来交给Browser Process进行加载，同时通知Browser Process，需要Plugin Process加载插件资源，执行插件代码。解析完成后，Renderer Process计算得到图像帧，并将这些图像帧交给GPU Process，GPU Process将其转化为图像显示屏幕。 即 标签页是渲染进程
```

Chrome浏览器是一个多进程程序,它主要包括

浏览器进程(Browser Process)

渲染进程(Renderer Process)

插件进程(Plugin Process)

GPU进程(GPU Process)

打开浏览器时会启动一个browser process,输入URL请求时会开启一个渲染进程(renderer process)

#### 渲染进程

渲染进程主要负责浏览器请求到html等代码后的解析与渲染工作,

它包括GUI线程,JS引擎线程,事件触发线程,定时器线程等

GUI线程就是走的关键渲染路径,通过构建dom tree css tree renderer tree 布局\绘制 重绘与回流的步骤,完成网页的渲染.

JS引擎线程主要负责解析js代码(v8引擎),其与GUI线程互斥,即会堵塞GUI线程的正常解析

事件触发线程:(event loop核心线程)触发的事件放入队列的尾部等待js引擎处理

所以为什么script会影响js解析,script属于js引擎线程,解析属于GUI线程,两者是互斥的.


## 浏览器缓存

缓存是一种简单直接地性能优化方法

### 

## Web存储

### cookie

由于HTTP是一种无状态协议,也就是建立连接,交换数据,断开连接这一过程后,再次发起请求,服务器并不知道客户端的身份.于是cookie应运而生,cookie是浏览器存储在本地的文件,用于下次客户端发送请求时告知服务端身份

修改cookie的api document.cookie

1. cookie被借用了存储的功能 
2. 大小限制在4KB
3. 每次都会携带在http头中，过量的cookie会损耗性能。
4. cookie是紧跟域名的，同一个域名下的所有请求，都会携带 Cookie。
5. 不够安全，服务器没法分辨用户和攻击者，攻击者可以读取网络上的其他用户的信息，包含HTTP Cookie的全部内容，以便进行中间的攻击。使用跨站点脚本技术可以窃取cookie等。

### WebStorage

1. 大小为5MB
2. 只发生在浏览器本地,不与服务器进行交换

## TCP/IP协议

### TCP与UDP的区别

1. TCP需要连接,UDP不用连接,直接传输数据
2. TCP是一对一的两点服务,UDP支持一对一与一对多
3. TCP是可靠交付,数据无差错,不丢失.UDP不保证可靠交付
4. !!(非必要不用回答)TCP有拥塞控制和流量控制,保证数据传输安全性.UDP没有,可以保证传输的效率
5. TCP面向:HTTP/FTP.UDP面向视频,音频等

## HTTP协议

五层模型:应用层HTTP 传输层TCP UDP 网络层IP 链路层 物理层

http是一种网络协议,解决了应用程序之间如果传输数据,应该以怎么样的格式传输数据的问题.

其底层基于TCP/IP协议,该协议解决了应用程序之间如何建立通信连接,以及如何通信的问题.

特点:

1. 可扩展:请求响应头,请求方法,状态码等都可以灵活拓展,这些都是随着时代发展所添加上去的.
2. 可靠传输:HTTP基于TCP/IP协议,TCP本身是一种可靠传输协议,本质是对传输的数据做上一层包装(加上一些头信息)然后利用socket API发送.可靠的就是信息能过正确的送达
3. 请求应答模式:顺序进入,顺序出去.一个请求,一个应答
4. 无状态:收发双方不知道对方的身份每一次的报文传输也是完全独立的.TCP协议就是有状态的,UDP不是
   1. 无状态可以减轻服务器记忆状态的负担,还可以不用任何判断的进行负载均衡实现高并发

5. 明文传输:截获的流量就是真实浏览的内容
6. 性能: 请求应答模式导致的队头阻塞,即顺序发送的请求如果遇到堵塞,后面排队的请求也会一并被堵塞

实体数据:  

浏览器接收到HTTP数据后,并不知道该数据是什么样的格式,于是规定MIME.同时传输数据存在压缩,规定Encoding Type

1. MIME,规定HTTP的数据类别 type/subtype 
   1. 对应请求头:Accept 响应头:Content-type 这个过程叫做内容协商
   2. text image audio video application
2. Encoding-type:gzip deflate br
   1. 对应 accept-encoding content-encoding
3. 其它编码格式,语言等也属于内容协商
   1. 使用q=value设置权重

长短连接:

1. 短连接每一次都要TCP连接,太浪费
2. 长连接(默认开启)
   1. 请求/响应头:Connection:keep-alive
3. 解决对头阻塞的问题,使用并发连接,也就是对同一个域名开启多个长连接,但这回造成服务器资源的问题

重定向: 301与302状态码等可以认为是重定向

​	1.重定向的地址有响应头:Location:/xxx.html决定

Cookie: 为了解决HTTP无状态的问题,使用cookie让服务器记住状态,除此之外,还有广告跟踪的功能(第三方cookie)

	1. 响应头Set-cookie,发给客户端,
	1. 客户端下次再请求时,使用cookie请求头,标明自己的身份
	3. cookie的属性
	 	1. expires与max-age(max-age的优先级更高):设置cookie的失效时间
	 	2. domin;path指定cookie所属的域名和路径,在发送cookie前,浏览器对比URL中的域名与路径是否与cookie中的一致,如果一致再发送请求.
	 	3. HttpOnly属性:只能通过http协议传输cookie,防止了XSS攻击(防止了诸如document.cookie的方法获取cookie)
	 	4. SameSite属性:SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送， 而“SameSite=Lax”允许 GET/HEAD 等方法，但禁止 POST 跨站发送。这防止了CSRF攻击,即如果跨站传输cookie的话会被禁止

### HTTP缓存

强缓存:在资源未过期之前.浏览器都不会向服务器请求资源,直接使用本地的缓存

主要响应头: expires cache-control

1. cache-control:max-age:5 这里的时间是从**报文创建的时间开始计算的**.即为Date字段
2. no-store:不存储缓存,用于数据变化非常频繁的数据,如秒杀界面
3. no-cache:使用缓存之前向服务器验证是否过期,不管缓存有没有过期
4. must-revalidate:如果缓存过期了,就向服务器校检,没过期直接用就可以了

![image-20221116200246630](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221116200246630.png)

​	5. 请求与响应都可以实现cache-control,如果请求头里添加了max-age=0,也就是缓存资源保存0s,也就相当于no-store.即服务器每次都要返回最新的资源

协商缓存:每一次都需要与服务器进行协商查看资源是否有更新,如果更新就重新获取资源,返回200.没有命中缓存,返回304

请求头:if-modified-since if

代理服务器

区分代理服务器↓

代理服务器作为客户端与服务器中间的中间人,一定程度上隐藏了服务器的真实信息1. 使用via字段,每次经过代理服务器时,都添加:via:proxy1,proxy2这样的字段

源服务器的缓存控制

1. private只能缓存在客户端,publlc缓存完全开发
2. 如果你登录论坛,返回的报文里set-cookie里有论坛ID,这个时候就不能再使用代理服务器缓存,只能存在客户端,否则就有泄露的风险
3. proxy-revalidate,缓存过期后,只验证到代理服务器这个级别就可以了
4. s-maxage,设置缓存在代理服务器上的缓存时间
5. no-transform:禁止代理服务器偷偷的改变一些数据

![image-20221116204510957](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221116204510957.png)

### HTTP状态码

响应报文中的响应头分为: HTTP版本号 状态码 原因(基本无用)

1. 1XX:表示处于通信的中间阶段,还需要继续操作

   101 Switching Protocols: 客户端通过Upgrade请求头告知更换请求协议,服务器同意更换,返回101状态码告知客户端更换协议

2. 2XX:表示服务端受到并成功处理了客户端的请求

   200 OK:正确的处理了请求

   204 Not Content:正确的处理了请求,但没有响应体

   206 Partial Content:客户端发送部分请求,要求获得部分资源,服务器返回的响应体只是一部分的情况.响应体中还有content-range的响应头,用于标记响应数据的大小

3. 3XX:表示客户端请求的数据发生变动,必须以新的URI发送请求

   1. 301 Moved Permanently:永久重定向,即资源不存在,需要改用新的URI
   2. 302 Found 临时重定向:资源临时不存在
   3. 304 Not Modified 用于浏览缓存,可以理解为:重定向到已经缓存的文件上
   4. (以下非常用)303 307 308


## HTTPS

http是明文传输,使用它来传输非常的不安全

https相比较http最大的变化就是下层协议变成了SSL/TLS

TLS是它的正式姓名,SSL只是习惯叫法

![image-20221115204258145](C:\Users\CXG\Desktop\Go\笔记\前端\面试题.assets\image-20221115204258145.png)

### 对称加密与非对称加密

1. 加密和解密的密钥都只是一个  

   在TLS中,常用的加密算法是:AES与ChaCha20

2. 公钥发给任何人,私钥只能自己保管

   常用的加密算法是: RSA 与 ECC

### 在TLS中使用的是混合加密

1. 首先使用非对称加密,解决密钥传输问题
2. 生成一个会话密钥,使用公钥加密这个会话密钥,发给接收方,接收方使用私钥解密,就完成了会话密钥的传输
3. 之后的方法就是用对称加密

### 摘要算法

混合加密并不能完全保证安全,摘要算法是为了保证消息的完整性

发送消息给服务器时,带上一个SHA-2的摘要,网站收到信息后计算摘要,然后进行对比.如果一致即说明消息完整.(注意要把消息与摘要通过会话密钥同时加密,防止摘要也被修改)

### 数字签名

数字签名存在的目的是保证双方的**身份认证**信息

数字签名的原理就是将非对称加密的原理返回来,以前是公钥加密,私钥解密.现在是私钥加密,公钥解密

通过私钥加密传输密文的摘要后的内容即为数字签名

浏览器通过自己的私钥加密发送给服务器的信息的摘要,服务器通过公钥解密后发现和接收的内容的摘要一致,服务器就确认了浏览器的身份信息.反过来也一样

### 数字证书认证机构(CA)

公钥任何人都有,可是怎么确定这个公钥就是某个网站公开的呢?使用CA

CA完整的证明了公钥的所有者信息,形成了数字证书

数字证书的级别: DV <OV< EV,在于数字证书的可信程度

CA证明自己的方法:根证书

## HTTP2

HTTP2相比较1,在规范上没有太大的变化,保留了协议名:http/https,这很好的保证了网站的兼容性

1. 头部压缩: 

   1. http1时期,通过content-encoding字段指定body的压缩格式,但是header的大小与内容依然很多 .使用HPACK算法进行头部压缩

2. 二进制格式

   由明文转换为二进制格式,把原来的“Header+Body”的消息“打散”为 数个小片的二进制“帧”（Frame），用“HEADERS”帧存放头数据、“DATA”帧存放 实体数据。

3. 流

   对往返的消息分配一个唯一的流ID,这样数据帧有了先后顺序,就可以正确的组成请求与响应把报文

   如此,流可以发送多个帧序列,也就是多路复用,

   改变请求响应的应答模式,服务器也可以主动的发送流给客户端,这叫做服务器推送

4. 强化安全

   在实际的应用场景上HTTP2就是使用https

## 网络安全

### XSS攻击

Cross Site Scripting(跨站脚本),即进行

就是尽可能的把可执行代码嵌入到网站中执行

持久型:把代码直接注入到数据库中,这么做可能危害到所有的网站使用用户

举例:评论区内输入`<script>alert('hhh')</script>`这样的

非持久型:通过浏览器传参来注入代码

解决方案:

将用户输入的内容进行改变,防止用户输入不该输入的内容

1. 字符替换(将可能的攻击字符转换成没有攻击可能的字符)
2. 使用白名单过滤(白名单中标明只接受哪种类型的标签) 请见 js

### CSRF攻击

跨站请求伪造,黑客编写一个请求代码,诱导用户的点击或在用户不知情的情况下发起请求,如果后端没有相应的防御措施,就会误以为是用户真正的发送了请求,造成用户隐私泄露;

解决方案:

1.验证referer: 验证站点请求来源,如果来源不为本站点,则后端拒绝请求;

2.验证token: 每次访问时,服务器下发一个token,进行请求时,浏览器携带token与服务器进行认证,如果认证通过就允许请求


